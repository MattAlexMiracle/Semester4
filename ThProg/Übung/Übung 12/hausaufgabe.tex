\documentclass{article}
\usepackage{listings}
\usepackage{mathrsfs}
\usepackage{cancel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{lipsum}
\usepackage{framed}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{scrextend}
\usepackage[english,german]{babel}
\usepackage{titling}
\usepackage{bm}
\usepackage{verbatim}
\usepackage{fourier}
\setlength{\droptitle}{-3cm}
\usepackage{tikz}
\usepackage{algorithm,algpseudocode}
\usepackage[doublespacing]{setspace}
\usepackage{minted}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\usepackage{polynom}
\usepackage{amsmath,amsthm}
\usepackage{gauss}
\usepackage{euscript}
\usepackage{tkz-euclide}
\usepackage{stackengine}
\usepackage{bussproofs}
\usepackage{tikz-cd}

\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}
\title{Übungsblatt 5}
\author{
Alexander Mattick Kennung: qi69dube\\
Kapitel 1
}
\usepackage{import}
\date{\today}
\geometry{a4paper, margin=2cm}
\usepackage{stackengine}
\parskip 1em
\newcommand\stackequal[2]{%
  \mathrel{\stackunder[2pt]{\stackon[4pt]{=}{$\scriptscriptstyle#1$}}{%
  $\scriptscriptstyle#2$}}
 }
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother
\lstset{
  language=haskell,
}
\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small}}{}
\usepackage{enumitem}
\setlist[itemize]{noitemsep, topsep=0pt}
\usepackage{titlesec}
\newcommand{\nto}{\nrightarrow}
\newcommand{\smallAscr}{\scriptscriptstyle\mathcal{A}}
%\newcommand{\nsqsubseteq}{\xout{\sqsubseteq}}
\title{Vorlesung 2}
\titlespacing*{\subsection}{0pt}{2pt}{3pt}
\titlespacing*{\section}{0pt}{0pt}{5pt}
\titlespacing*{\subsubsection}{0pt}{1pt}{2pt}
\newtheorem{satz}{Satz}
\newtheorem{korrolar}{Korrolar}[section]
\newtheorem{lemma}{Lemma}[section]

\theoremstyle{definition}
\newtheorem{beweis}{Beweis}[section]
\newtheorem{beispiel}{Beispiel}[section]
\newtheorem{definition}{Definition}[section]


\begin{document}
	\maketitle
	leaf x $ = \lambda\ x.\ \lambda\ u\ h\ .\ u\ x $\\
  Hintergrundlogik: leaf x nimmt einen parameter auf, deshalb $\lambda\ x$ außerdem ist der Typ von BinTree ein $\forall s .\underbrace{(a\to s)}_{\widehat{=} u}\to \underbrace{(s\to s \to s)}_{\widehat{=} h} \to s$ damit auf beide Fälle zugegriffen werden kann (das element und der evtl. existente nachfolger h)\\
  bin l r = $\lambda\ l\ r\ .\lambda\ u\ h.h (l\ u\ h)\ (r\ u\ h) $\\
  Hintergrundlogik: wir haben zwei Teilbäume l und r und wenden in beiden die f funktion an (die aus den teilen u und h besteht). h gibt an, wie im fold schema die Knoten umzuformen sind und u wie die leaves umzuformen sind (das stimmt nicht 100\% aber ist nahe genug, um es als Gedankestütze zu verwenden)\\
  \begin{prooftree}
    \AxiomC{}
    \LeftLabel{$(AX)$}
    \UnaryInfC{$x:a$}
    \AxiomC{}
    \LeftLabel{$(AX)$}
    \UnaryInfC{$u:a\to s$}
    \LeftLabel{$\to_e$}
    \BinaryInfC{$\{x:a,u:(a\to s),h:(s\to s\to s)\}\vdash\ u\ x:s$}
    \LeftLabel{$\to_i$}
    \UnaryInfC{$\{x:a,u:(a\to s)\}\vdash \lambda h\ .\ u\ x: (s\to s\to s)\to s$}
    \LeftLabel{$\to_i$}
    \UnaryInfC{$\{x:a\}\vdash \lambda u\ h\ .\ u\ x: (a\to s)\to (s\to s\to s)\to s$}
    \AxiomC{$s\notin FV(\{x:a\})$}
    \LeftLabel{$\forall_i$}
    \BinaryInfC{$\{x:a\}\vdash \lambda u\ h\ .\ u\ x: \forall s.(a\to s)\to (s\to s\to s)\to s$}
    \LeftLabel{$\to_i$}
    \UnaryInfC{$\vdash \lambda\ x.\ \lambda\ u\ h\ .\ u\ x :a\to BinTree\ a$}
    \AxiomC{$a\notin FV(\emptyset)$}
    \LeftLabel{$\forall_i$}
    \BinaryInfC{$\vdash leaf:\forall a.a\to BinTree\ a$}
  \end{prooftree}


	
\end{document}



